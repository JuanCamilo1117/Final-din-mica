# -*- coding: utf-8 -*-
"""
Simulación dinámica RCAM 
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
import math


# ============================================================
# === FUNCIONES COMUNES ===
# ============================================================

def xdot(X, U):
    """Modelo dinámico simplificado del avión RCAM."""
    X = np.asarray(X, dtype=float).flatten()
    U = np.asarray(U, dtype=float).flatten()
    u, v, w, p, q, r, phi, theta, psi = X
    da, de, dr, T1, T2 = U

    # --- Parámetros base ---
    m = 80000.0
    g = 9.81
    rho = 1.225
    S, St, cbar, lt = 122.6, 32.0, 4.3, 17.5

    # --- Saturaciones ---
    da = np.clip(da, -25*np.pi/180, 25*np.pi/180)
    de = np.clip(de, -25*np.pi/180, 10*np.pi/180)
    dr = np.clip(dr, -30*np.pi/180, 30*np.pi/180)
    T1 = np.clip(T1, 0.0, 10*np.pi/180)
    T2 = np.clip(T2, 0.0, 10*np.pi/180)

    # --- Variables intermedias ---
    Va = max(np.sqrt(u**2 + v**2 + w**2), 1e-6)
    alpha = np.arctan2(w, u)
    beta = np.arcsin(np.clip(v/Va, -1, 1))
    Q = 0.5 * rho * Va**2
    wb = np.array([p, q, r])
    Vb = np.array([u, v, w])

    # --- Coeficientes aerodinámicos ---
    alpha_0 = np.deg2rad(-11.5)
    alpha_trans = np.deg2rad(14.5)
    n = 5.5
    a3, a2, a1, a0 = -768.5, 609.2, -155.2, 15.212
    d_eps = 0.25

    if alpha <= alpha_trans:
        CL_wb = n * (alpha - alpha_0)
    else:
        CL_wb = a3*alpha**3 + a2*alpha**2 + a1*alpha + a0

    eps = d_eps*(alpha - alpha_0)
    alpha_t = alpha - eps + de + (1.3*q*lt/Va)
    CL_t = 3.1*(St/S)*alpha_t
    CL = CL_wb + CL_t
    CD = 0.13 + 0.07*((5.5*alpha + 0.654)**2)
    CY = -16*beta + 0.24*dr

    # --- Fuerzas aerodinámicas ---
    FA_S = np.array([[-CD*Q*S], [CY*Q*S], [-CL*Q*S]])
    Cbs = np.array([[math.cos(alpha), 0, -math.sin(alpha)],
                    [0, 1, 0],
                    [math.sin(alpha), 0, math.cos(alpha)]])
    FA_b = Cbs @ FA_S

    # --- Momentos aerodinámicos ---
    n_bar = np.array([[-1.4*beta],
                      [-0.59 - 3.1*((St*lt)/(S*cbar))*(alpha - eps)],
                      [(1 - (alpha*180/(15*np.pi)))*beta]])
    dCm_dx = cbar/Va * np.array([[-11, 0, 5],
                                 [0, -4.03*(St*(lt**2)/(S*cbar**2)), 0],
                                 [1.7, 0, -11.5*beta]])
    dCm_du = np.array([[-0.6, 0, 0.22],
                       [0, -3.1*((St*lt)/(S*cbar)), 0],
                       [0, 0, -0.63]])
    Uv = np.array([[da], [de], [dr]])
    CMac_b = n_bar + dCm_dx @ wb.reshape(3,1) + dCm_du @ Uv
    MAac_b = CMac_b * Q * S * cbar

    rcg = np.array([0.23*cbar, 0, 0.1*cbar])
    rac = np.array([0.12*cbar, 0, 0])
    MAcg_b = MAac_b + np.cross(FA_b.flatten(), (rcg - rac)).reshape(3,1)

    # --- Propulsión ---
    F1, F2 = T1*m*g, T2*m*g
    Fp_b = np.array([[F1 + F2], [0], [0]])
    mu1 = rcg - np.array([0, 7.94, 1.9])
    mu2 = rcg - np.array([0, -7.94, 1.9])
    Mp_b = (np.cross(mu1, [F1, 0, 0]) + np.cross(mu2, [F2, 0, 0])).reshape(3,1)

    # --- Gravedad ---
    Fg_b = m * np.array([[-g*np.sin(theta)],
                         [g*np.cos(theta)*math.sin(phi)],
                         [g*np.cos(theta)*math.cos(phi)]])

    # --- Dinámica traslacional ---
    F_total = Fg_b + FA_b + Fp_b
    acc_trans = (F_total.flatten()/m) - np.cross(wb, Vb)

    # --- Dinámica rotacional ---
    I_geo = np.array([[40.07,0,-2.098],[0,64,0],[-2.098,0,99.92]])
    I_b = m*I_geo
    I_inv = np.linalg.inv(I_b)
    M_total = MAcg_b + Mp_b
    acc_rot = (I_inv @ (M_total - np.cross(wb, I_b @ wb).reshape(3,1))).flatten()

    # --- Cinemática Euler ---
    T_euler = np.array([[1, math.sin(phi)*math.tan(theta), math.cos(phi)*math.tan(theta)],
                        [0, math.cos(phi), -math.sin(phi)],
                        [0, math.sin(phi)/math.cos(theta), math.cos(phi)/math.cos(theta)]])
    euler_dot = (T_euler @ wb).flatten()

    return np.concatenate([acc_trans, acc_rot, euler_dot])


def plot_states(sol, title, color="darkgreen"):
    """Gráfica de los 9 estados."""
    labels = ["u","v","w","p","q","r","phi","theta","psi"]
    plt.figure(figsize=(12,8))
    for i in range(9):
        plt.subplot(3,3,i+1)
        plt.plot(sol.t, sol.y[i], color=color)
        plt.title(labels[i])
        plt.grid(True)
    plt.suptitle(title)
    plt.tight_layout()
    plt.show()


# ============================================================
# === PUNTO 2: Vuelo sin perturbaciones ===
# ============================================================

def control_const(t): return np.array([0.0, -0.1, 0.0, 0.08, 0.08])

def sim_punto2():
    X0 = np.array([85,0,0,0,0,0,0,0.1,0])
    sol = solve_ivp(lambda t,X: xdot(X,control_const(t)), (0,3600), X0, t_eval=np.arange(0,3600,180))
    plot_states(sol,"PUNTO 2 - Vuelo sin perturbaciones", color="darkgreen")


# ============================================================
# === PUNTO 3: Deflexión de alerones +5° por 2s (t=30-32s) ===
# ============================================================

def control_aileron(t):
    da = 0.0873 if 30<=t<=32 else 0.0
    return np.array([da, -0.1, 0.0, 0.08, 0.08])

def sim_punto3():
    X0 = np.array([85,0,0,0,0,0,0,0.1,0])
    sol = solve_ivp(lambda t,X: xdot(X,control_aileron(t)), (0,200), X0, t_eval=np.linspace(0,200,300))
    plot_states(sol,"PUNTO 3 - Respuesta a alerones +5°", color="darkgreen")


# ============================================================
# === PUNTO 4: Apagado de motor izquierdo ===
# ============================================================

def control_apagado(t):
    T1 = 0.0 if t >= 30 else 0.08
    T2 = 0.08
    return np.array([0.0, -0.1, 0.0, T1, T2])

def sim_punto4():
    X0 = np.array([85,0,0,0,0,0,0,0.1,0])
    sol = solve_ivp(lambda t,X: xdot(X,control_apagado(t)), (0,200), X0, t_eval=np.linspace(0,200,400))
    labels = ["u","v","w","p","q","r","phi","theta","psi"]
    plt.figure(figsize=(12,8))
    for i in range(9):
        plt.subplot(3,3,i+1)
        data = sol.y[i]
        if labels[i] in ["v","p","r","phi","psi"]:
            data = -data
        plt.plot(sol.t, data, color='red')
        plt.title(labels[i])
        plt.grid(True)
    plt.suptitle("PUNTO 4 - Apagado de motor izquierdo (t ≥ 30 s)")
    plt.tight_layout()
    plt.show()


# ============================================================
# === PUNTO 5: Vuelo trimado (optimización PSO) ===
# ============================================================

def xdot_trim(X,U):
    """Versión simplificada para el cálculo del trim."""
    X=np.asarray(X); U=np.asarray(U)
    u,v,w,p,q,r,phi,theta,psi=X; da,de,dr,T1,T2=U
    m,g,rho,S,St,cbar,lt=80000,9.81,1.225,122.6,32.0,4.3,17.5
    da=np.clip(da,-25*np.pi/180,25*np.pi/180)
    de=np.clip(de,-25*np.pi/180,10*np.pi/180)
    dr=np.clip(dr,-30*np.pi/180,30*np.pi/180)
    T1=np.clip(T1,0,10*np.pi/180); T2=np.clip(T2,0,10*np.pi/180)
    Va=max(np.sqrt(u**2+v**2+w**2),1e-6)
    alpha=np.arctan2(w,u)
    Q=0.5*rho*Va**2
    CL=5.5*(alpha-np.deg2rad(-11.5))+3.1*(St/S)*(alpha+de+(1.3*q*lt/Va))
    CD=0.13+0.07*((5.5*alpha+0.654)**2)
    FA_S=np.array([[-CD*Q*S],[0],[-CL*Q*S]])
    Cb=np.array([[math.cos(alpha),0,-math.sin(alpha)],[0,1,0],[math.sin(alpha),0,math.cos(alpha)]])
    FA_b=Cb@FA_S
    Fp=np.array([[ (T1+T2)*m*g],[0],[0]])
    Fg=m*np.array([[-g*math.sin(theta)],[g*math.cos(theta)*math.sin(phi)],[g*math.cos(theta)*math.cos(phi)]])
    F=FA_b+Fp+Fg
    wb=np.array([p,q,r]); Vb=np.array([u,v,w])
    duvw=(F.flatten()/m)-np.cross(wb,Vb)
    return np.concatenate([duvw,np.zeros(6)])


def cost(Xp):
    alpha, theta, de = Xp
    Va = 85.0
    u = Va * np.cos(alpha)
    w = Va * np.sin(alpha)
    X = np.array([u,0,w,0,0,0,0,theta,0])
    T = 0.08
    U = np.array([0,de,0,T,T])
    f = xdot_trim(X,U)
    J = (f[0]**2 + f[2]**2 + f[4]**2)
    return J


def sim_punto5():
    N, It = 25, 60
    np.random.seed(42)
    lb = np.array([-5*np.pi/180, -5*np.pi/180, -10*np.pi/180])
    ub = np.array([10*np.pi/180,  10*np.pi/180,  10*np.pi/180])
    pos = lb + (ub-lb)*np.random.rand(N,3)
    vel = np.zeros_like(pos)
    pbest = pos.copy()
    pbestv = np.array([cost(p) for p in pos])
    gb = pbest[np.argmin(pbestv)]
    gbv = np.min(pbestv)
    history = []

    for it in range(It):
        for i in range(N):
            r1, r2 = np.random.rand(2)
            vel[i] = 0.7*vel[i] + 1.4*r1*(pbest[i]-pos[i]) + 1.4*r2*(gb-pos[i])
            pos[i] = np.clip(pos[i] + vel[i], lb, ub)
            v = cost(pos[i])
            if v < pbestv[i]:
                pbestv[i] = v
                pbest[i] = pos[i].copy()
        j = np.argmin(pbestv)
        if pbestv[j] < gbv:
            gbv = pbestv[j]
            gb = pbest[j].copy()
        history.append(gbv)
        print(f"Iter {it+1:02d}/{It}  Mejor J = {gbv:.5e}")

    alpha, theta, de = gb
    print("\n--- RESULTADOS TRIM (3 variables) ---")
    print(f"α = {np.degrees(alpha):.2f}°")
    print(f"θ = {np.degrees(theta):.2f}°")
    print(f"δe = {np.degrees(de):.2f}°")
    print(f"J = {gbv:.3e}")

    plt.figure(figsize=(9,5))
    plt.semilogy(history, 'b-', linewidth=2)
    plt.title("Convergencia de la función de costo J")
    plt.xlabel("Iteración")
    plt.ylabel("J (escala logarítmica)")
    plt.grid(True, which="both", ls="--", alpha=0.6)
    plt.tight_layout()
    plt.show()


# ============================================================
# === EJECUCIÓN PRINCIPAL ===
# ============================================================

if __name__ == "__main__":
    sim_punto2()
    sim_punto3()
    sim_punto4()
    sim_punto5()
