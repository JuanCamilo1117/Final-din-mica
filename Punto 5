# -*- coding: utf-8 -*-
"""
Simulación punto 5 - Vuelo trimado (3 variables)
Ahora grafica la convergencia de la función de costo (J)
"""

import numpy as np
import matplotlib.pyplot as plt
import math
from scipy.integrate import solve_ivp

def xdot(X,U):
    X=np.asarray(X); U=np.asarray(U)
    u,v,w,p,q,r,phi,theta,psi=X; da,de,dr,T1,T2=U
    m,g,rho,S,St,cbar,lt=80000,9.81,1.225,122.6,32.0,4.3,17.5
    da=np.clip(da,-25*np.pi/180,25*np.pi/180)
    de=np.clip(de,-25*np.pi/180,10*np.pi/180)
    dr=np.clip(dr,-30*np.pi/180,30*np.pi/180)
    T1=np.clip(T1,0,10*np.pi/180); T2=np.clip(T2,0,10*np.pi/180)
    Va=max(np.sqrt(u**2+v**2+w**2),1e-6)
    alpha=np.arctan2(w,u)
    beta=np.arcsin(np.clip(v/Va,-1,1))
    Q=0.5*rho*Va**2
    CL=5.5*(alpha-np.deg2rad(-11.5))+3.1*(St/S)*(alpha+de+(1.3*q*lt/Va))
    CD=0.13+0.07*((5.5*alpha+0.654)**2)
    CY=-16*beta+0.24*dr
    FA_S=np.array([[-CD*Q*S],[CY*Q*S],[-CL*Q*S]])
    Cb=np.array([[math.cos(alpha),0,-math.sin(alpha)],
                 [0,1,0],
                 [math.sin(alpha),0,math.cos(alpha)]])
    FA_b=Cb@FA_S
    Fp=np.array([[ (T1+T2)*m*g],[0],[0]])
    Fg=m*np.array([[-g*math.sin(theta)],
                   [g*math.cos(theta)*math.sin(phi)],
                   [g*math.cos(theta)*math.cos(phi)]])
    F=FA_b+Fp+Fg
    wb=np.array([p,q,r]); Vb=np.array([u,v,w])
    duvw=(F.flatten()/m)-np.cross(wb,Vb)
    return np.concatenate([duvw,np.zeros(6)])


# --- Función de costo ---
def cost(Xp):
    alpha, theta, de = Xp
    Va = 85.0
    u = Va * np.cos(alpha)
    w = Va * np.sin(alpha)
    X = np.array([u,0,w,0,0,0,0,theta,0])
    T = 0.08
    U = np.array([0,de,0,T,T])
    f = xdot(X,U)
    # minimizar aceleraciones longitudinales y angulares
    J = (f[0]**2 + f[2]**2 + f[4]**2)
    return J


# --- Configuración del PSO ---
N, It = 25, 60
np.random.seed(42)
lb = np.array([-5*np.pi/180, -5*np.pi/180, -10*np.pi/180])
ub = np.array([10*np.pi/180,  10*np.pi/180,  10*np.pi/180])

pos = lb + (ub-lb)*np.random.rand(N,3)
vel = np.zeros_like(pos)
pbest = pos.copy()
pbestv = np.array([cost(p) for p in pos])
gb = pbest[np.argmin(pbestv)]
gbv = np.min(pbestv)

# para graficar la convergencia
history = []

for it in range(It):
    for i in range(N):
        r1, r2 = np.random.rand(2)
        vel[i] = 0.7*vel[i] + 1.4*r1*(pbest[i]-pos[i]) + 1.4*r2*(gb-pos[i])
        pos[i] = np.clip(pos[i] + vel[i], lb, ub)
        v = cost(pos[i])
        if v < pbestv[i]:
            pbestv[i] = v
            pbest[i] = pos[i].copy()
    j = np.argmin(pbestv)
    if pbestv[j] < gbv:
        gbv = pbestv[j]
        gb = pbest[j].copy()
    history.append(gbv)
    print(f"Iter {it+1:02d}/{It}  Mejor J = {gbv:.5e}")

alpha, theta, de = gb
print("\n--- RESULTADOS TRIM (3 variables) ---")
print(f"α = {np.degrees(alpha):.2f}°")
print(f"θ = {np.degrees(theta):.2f}°")
print(f"δe = {np.degrees(de):.2f}°")
print(f"J = {gbv:.3e}")

# --- Gráfica de convergencia ---
plt.figure(figsize=(9,5))
plt.semilogy(history, 'b-', linewidth=2)
plt.title("Convergencia de la función de costo J")
plt.xlabel("Iteración")
plt.ylabel("J (escala logarítmica)")
plt.grid(True, which="both", ls="--", alpha=0.6)
plt.tight_layout()
plt.show()
