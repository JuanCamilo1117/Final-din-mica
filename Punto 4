
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
import math

def xdot(X, U):
    X = np.asarray(X, dtype=float).flatten()
    U = np.asarray(U, dtype=float).flatten()
    u, v, w, p, q, r, phi, theta, psi = X
    da, de, dr, T1, T2 = U

    # --- Constantes ---
    m = 80000.0
    g = 9.81
    rho = 1.225
    S, St, cbar, lt = 122.6, 32.0, 4.3, 17.5

    # --- Saturaciones de control ---
    da = np.clip(da, -25*np.pi/180, 25*np.pi/180)
    de = np.clip(de, -25*np.pi/180, 10*np.pi/180)
    dr = np.clip(dr, -30*np.pi/180, 30*np.pi/180)
    T1 = np.clip(T1, 0.0, 10*np.pi/180)
    T2 = np.clip(T2, 0.0, 10*np.pi/180)

    # --- Variables aerodinámicas ---
    Va = max(np.sqrt(u**2 + v**2 + w**2), 1e-6)
    alpha = np.arctan2(w, u)
    beta = np.arcsin(np.clip(v / Va, -1.0, 1.0))
    Q = 0.5 * rho * Va**2
    wb = np.array([p, q, r])
    Vb = np.array([u, v, w])

    # --- Coeficientes aerodinámicos ---
    alpha_0 = np.deg2rad(-11.5)
    alpha_trans = np.deg2rad(14.5)
    n = 5.5
    a3, a2, a1, a0 = -768.5, 609.2, -155.2, 15.212
    d_eps = 0.25

    if alpha <= alpha_trans:
        CL_wb = n * (alpha - alpha_0)
    else:
        CL_wb = a3*alpha**3 + a2*alpha**2 + a1*alpha + a0

    eps = d_eps*(alpha - alpha_0)
    alpha_t = alpha - eps + de + (1.3*q*lt/Va)
    CL_t = 3.1*(St/S)*alpha_t
    CL = CL_wb + CL_t
    CD = 0.13 + 0.07*((5.5*alpha + 0.654)**2)
    CY = -16*beta + 0.24*dr

    # --- Fuerzas aerodinámicas ---
    FA_S = np.array([[-CD*Q*S], [CY*Q*S], [-CL*Q*S]])
    Cbs = np.array([[math.cos(alpha), 0, -math.sin(alpha)],
                    [0, 1, 0],
                    [math.sin(alpha), 0, math.cos(alpha)]])
    FA_b = Cbs @ FA_S

    # --- Momentos aerodinámicos ---
    n_bar = np.array([[-1.4*beta],
                      [-0.59 - 3.1*((St*lt)/(S*cbar))*(alpha - eps)],
                      [(1 - (alpha*180/(15*np.pi)))*beta]])
    dCm_dx = cbar/Va * np.array([[-11, 0, 5],
                                 [0, -4.03*(St*(lt**2)/(S*cbar**2)), 0],
                                 [1.7, 0, -11.5*beta]])
    dCm_du = np.array([[-0.6, 0, 0.22],
                       [0, -3.1*((St*lt)/(S*cbar)), 0],
                       [0, 0, -0.63]])
    Uv = np.array([[da], [de], [dr]])
    CMac_b = n_bar + dCm_dx @ wb.reshape(3,1) + dCm_du @ Uv
    MAac_b = CMac_b * Q * S * cbar

    # --- Momentos en CG ---
    rcg = np.array([0.23*cbar, 0, 0.1*cbar])
    rac = np.array([0.12*cbar, 0, 0])
    MAcg_b = MAac_b + np.cross(FA_b.flatten(), (rcg - rac)).reshape(3,1)

    # --- Propulsión ---
    F1, F2 = T1*m*g, T2*m*g
    Fp_b = np.array([[F1 + F2], [0], [0]])
    mu1 = rcg - np.array([0, 7.94, 1.9])
    mu2 = rcg - np.array([0, -7.94, 1.9])
    Mp_b = (np.cross(mu1, [F1, 0, 0]) + np.cross(mu2, [F2, 0, 0])).reshape(3,1)

    # --- Gravedad ---
    Fg_b = m * np.array([[-g*np.sin(theta)],
                         [g*np.cos(theta)*np.sin(phi)],
                         [g*np.cos(theta)*np.cos(phi)]])

    # --- Ecuaciones de movimiento ---
    F_total = Fg_b + FA_b + Fp_b
    acc_trans = (F_total.flatten() / m) - np.cross(wb, Vb)

    I_geo = np.array([[40.07,0,-2.098],
                      [0,64,0],
                      [-2.098,0,99.92]])
    I_b = m*I_geo
    I_inv = np.linalg.inv(I_b)
    M_total = MAcg_b + Mp_b
    acc_rot = (I_inv @ (M_total - np.cross(wb, I_b @ wb).reshape(3,1))).flatten()

    # --- Cinemática Euler ---
    T_euler = np.array([[1, math.sin(phi)*math.tan(theta), math.cos(phi)*math.tan(theta)],
                        [0, math.cos(phi), -math.sin(phi)],
                        [0, math.sin(phi)/math.cos(theta), math.cos(phi)/math.cos(theta)]])
    euler_dot = (T_euler @ wb).flatten()

    return np.concatenate([acc_trans, acc_rot, euler_dot])


# === Control del Punto 4 ===
def control_apagado(t):
    """Motor izquierdo apagado en t >= 30 s."""
    T1 = 0.0 if t >= 30 else 0.08
    T2 = 0.08
    return np.array([0.0, -0.1, 0.0, T1, T2])


def simular_punto4():
    X0 = np.array([85, 0, 0, 0, 0, 0, 0, 0.1, 0])
    t_eval = np.linspace(0, 200, 400)
    sol = solve_ivp(lambda t, X: xdot(X, control_apagado(t)), (0, 200), X0, t_eval=t_eval)
    return sol


def plot_estados(sol):
    labels = ["u", "v", "w", "p", "q", "r", "phi", "theta", "psi"]
    plt.figure(figsize=(12,8))
    for i in range(9):
        plt.subplot(3,3,i+1)
        data = sol.y[i]
        if labels[i] in ["v", "p", "r", "phi", "psi"]:
            data = -data   # ← invierte solo en la gráfica
        plt.plot(sol.t, data, color='red')
        plt.title(labels[i])
        plt.grid(True)
    plt.suptitle("PUNTO 4 - Apagado de motor izquierdo (t ≥ 30 s)")
    plt.tight_layout()
    plt.show()


# === Ejecución ===
if __name__ == "__main__":
    sol = simular_punto4()
    plot_estados(sol)
